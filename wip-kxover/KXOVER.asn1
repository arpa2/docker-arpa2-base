-- # Impromptu Realm Crossover for Kerberos (KXOVER)
--
-- > *We sometimes want to connect KDCs that are hitherto unknown, for instance
-- > because they are independently operated realms on the Internet, and a user
-- > in one realm wants to approach a service managed in another.  To do this,
-- > we need an exchange called KXOVER below.*

-- The KXOVER or `KX` exchange consists of a `KX-REQ` request message and a
-- `KX-REP` reply message.  This exchange establishes an intention to setup
-- a key for realm crossover, with a limited life time and validation based
-- on certificates, exchanged through an underlying TLS connection and validated
-- through DNSSEC/DANE and, possibly, LDAP.

-- The primary use case of KXOVER is for use from a client KDC to a service KDC.
-- In this use case, the identities will take the general crossover form of
-- `krbtgt/SERVICE.REALM@CLIENT.REALM` with `name-type` set to `NT-SRV-INST`.
-- Based on a crossover key established between KDCs, the client KDC can send
-- a constructive response to the client, telling it to follow a crossover
-- ticket and try elsewhere.  Most clients do this already, as part of the
-- canonicalization process.  The client KDC must be able to recognise where
-- to send a client request, and should therefore look for a DNSSEC-protected
-- _kerberos TXT record under the service hostname to find the target realm
-- in the first string of that TXT record.

-- A secondary use of KXOVER could be from a client directly to a KDC, in
-- which case more forms for the PrincipalName are possible.  The client
-- would need to know where to go, possibly using the same _kerberos TXT
-- records with DNSSEC protection that the KDC would investigate.  At the
-- expense of more complicated client code, there is a benefit of not
-- having the client KDC in the loop, able to decrypt the traffic to the
-- targeted service.
-- TODO: How to know if a realm would welcome that?  Use the 2nd TXT string?

-- A third use of KXOVER could be to get a ticket for the client's own realm.
-- This would effectively be an alternative to PKINIT, founded on a different
-- cryptographic basis.  Whether this is better would be a local choice in
-- the client realm.


-- ## KDC request/response messages

-- The messages exchanged for Impromptu Realm Crossover follow the same
-- general habits as those for `KDC-REQ` and `KDC-REP` messages, but they
-- are clearly distinguishable.  This allows routing them away from the
-- KDC, and allow "wrap-around" or "bump-in-the-wire" extensions to an
-- existing KDC.  Furthermore, the definitions can be more clearly and
-- more stringently than when using expanding on existing definitions.
-- The messages use application tags `[APPLICATION 18]` and
-- `[APPLICATION 19]` which are not used in any current IETF standard for
-- Kerberos, so there should be no confusion.

-- Unlike other KDC messages, the `KX-REQ` and `KX-REP` messages are always
-- exchanged over TLS.  To this end, a TCP connection is made and the
-- STARTTLS extension requested.  After having completed the handshake,
-- the TLS client sends a `KX-REQ` and in response the TLS server replies
-- with a `KX-REP`.  It is possible for the TLS client to initiate multiple
-- KXOVER exchanges over the same TLS connection.  This might be used to
-- validate multiple combinations of client and service realm based on the
-- same TLS exchange.

-- Unlike local clients, who already share a secret with their KDC to
-- protect their traffic, there is no such prior security relation between
-- two randomly connecting KDCs.  To establish trust, we use DANE and DNSSEC,
-- where the declaration of the KDC in terms of SRV records in DNS is used to
-- locate the port and transport for the KDC, which is in turn used to lookup
-- TLSA records to provide validation information for certificates that are
-- authoritative for the realm.  Such a certificate must mention a host name
-- of the KDC as well as a Subject Alternative Name for the Kerberos identity
-- of the represented party.  When the client is not a KDC, then its KDC is
-- still used to find DANE/DNSSEC validation for the client certificate,
-- though failing so there may (also) be a fallback mechanism through an LDAP
-- service for the realm's domain.

KXOVER DEFINITIONS EXPLICIT TAGS ::= BEGIN

IMPORTS PrincipalName, Realm, Authenticator,
        KerberosTime, Int32, UInt32 FROM RFC4120

        id-pkinit-san, KRB5PrincipalName FROM RFC4556

        Certificate, AlgorithmIdentifier, SubjectPublicKeyInfo,
        AuthorityKeyIdentifier, SubjectAltName, OtherName FROM RFC5280;

-- A few definitions for readability, in line with RFC 4120:

EncryptionType   ::=  Int32
KeyVersionNumber ::= UInt32


-- The `KX-REQ` and `KX-REP` messages use an `[APPLICATION n]` tag that is not
-- currently in use by any IETF-specified Kerberos protocol.  This makes them
-- easily distinguishable when sent over the same transport as Kerberos' other
-- messaging to and from a KDC.

KX-REQ ::= [APPLICATION 18] KX-REQ-MSG

KX-REP ::= [APPLICATION 19] KX-REP-MSG

-- The `KX-REQ-MSG` is the special KDC request for the `KX` exchange; its main
-- purpose is to request the setup of a shared key, usually across realms.

KX-REQ-MSG ::= SEQUENCE {
        pvno            [0] INTEGER (5) ,
        msg-type        [1] INTEGER (18) --KX-REQ--,
        offer           [2] KX-OFFER,
        ...
}


-- The `KX-REP-MSG` is the special KDC request for the `KX` exchange; its main
-- purpose is to respond to a shared key setup request, usually across realms.

KX-REP-MSG ::= SEQUENCE {
        pvno            [0] INTEGER (5),
        msg-type        [1] INTEGER (19) --KX-REP--,
        offer           [2] KX-OFFER,
        ...
}

-- The extension facility `...` in `KX-REQ-MSG` and `KX-REP-MSG` exists for
-- possible future extensions, such as direct connections from clients to a
-- (foreign) KDC in a style that may be reminiscent of PKINIT.  Upon reception,
-- KDCs that do not understand such extensions MUST ignore them.



-- ## The "symmetric" part of the KXOVER key exchange
-- 
-- The `KX-OFFER` is a symmetric exchange for the TLS-protected key exchange.
-- Both sides can explain their preferences, and learn from each other.  There
-- is however a difference between initiative, so there is some variation in
-- the details of the exchange.
--
-- Since the purpose of KXOVER is to communicate with unrelated peers on the
-- Internet, the protocol is more accurately specified than general Kerberos.
-- For this reason there is no facilitation of `KerberosFlags`.
-- 
-- Inspection of certificate hierarchies is optional, but it may be of use
-- in federated networks.  In the most general case, where the purpose is to
-- span the entire Internet with KXOVER, there is no use for certificate
-- hierarchies; validation through DANE/DNSSEC suffices, and the procedures
-- presented here assure that it belongs to a realm and the domain name to
-- which it maps; this suffices to assure that keys are being setup between
-- the realms at hand.

KX-OFFER ::= SEQUENCE {

     -- Ensuring signature freshness:
        request-time    [0] KerberosTime,
        salt            [1] OCTET STRING,

     -- Key description information:
        kx-name         [2] KRB5PrincipalName,
        kvno            [3] KeyVersionNumber,
        etypes          [4] SEQUENCE OF EncryptionType,

     -- Timing information:
        from            [5] KerberosTime,
        till            [6] KerberosTime,

     -- Sender description information:
        my-name         [7] KRB5PrincipalName,

     -- Extensions, each identified by an OID:
        extensions      [8] SEQUENCE OF KX-OFFER-EXTENSION

}

-- The fields of this structure are defined as follows:
-- 
--   * The `request-time` ties a timestamp into the `KX-TBSDATA`.  Since signing
--     is assumed to be done on demand, the timing may be assumed to be very
--     close to the current wallclock time.  KDCs are already required to follow
--     a timekeeping discipline, so this is no new requirement.  The `KX-REP`
--     MUST replicate the value from the `KX-REQ`.  No two requests from the
--     same KDC host may use the same `request-time` value; this includes
--     retries of a `KX-OFFER`.
--
--   * The `salt` is a local string of bytes that will be used when establishing
--     a unique key.  The TLS connection holds some local salt as well, but its
--     size may not be sufficiently flexible, or its source may not be relied
--     upon.  The `salt` MAY be empty, but it MAY also range up to the length
--     of the longest key for any of the proposed encryption types.  As long as
--     this is permitted, a recipient MAY disapprove of `salt` if it is
--     unreasonably long.
-- 
--   * The `kx-name`, `req-name` and `rep-name` all hold a PrincipalName and
--     Realm; `kx-name` names the key being setup through KXOVER, `req-name`
--     and `rep-name` represent the sender of the `KX-REQ` and `KX-REP`,
--     respectively.
--
--     When representing a KDC, the `name-type` MUST be set to `NT-SRV-INST`
--     with value 2, the number of `name-string` values MUST be 2, the first
--     set literally to `krbtgt` and the second set to the same value as the
--     Realm (this deliberatly disables KDCs to act on behalf of others).
--
--     When representing a service on a named host, the `name-type` MUST be
--     set to one of `NT-SRV-HST` or `NT-SRV-XHST` with values 3 or 4
--     respectively, and the number of `name-string` values MUST be 2 or more
--     than 2, respectively.
--
--     When representing a client, the `name-type` MUST NOT be one of the
--     values `NT-UNKNOWN`, `NT-SRV-INST`, `NT-SRV-HST` and `NT-SRV-XHST`
--     with values 0, 2, 3 and 4 and the number of `name-string` values MUST
--     be at least 1.
--
--     Note that the various name fields allow a number of different schemes
--     for realm crossover; between two KDCs, between client and KDC, between
--     service and KDC, between client and service, but also between two
--     clients or between two services.  The trick in these cases would be
--     to setup the TLS connection.  The certificate format shall contain
--     the exact name as represented in `rep-name` and `req-name` on the
--     side of the sender of the `KX-REP` and `KX-REQ`, respectively.  When
--     more than one of these messages is exchanged, it is possible to use
--     a different `rep-name` or `req-name` in each, thanks to the possible
--     occurrence of multiple names in one end point's certificate.
--
--   * The `kvno` is a key version number as used in Kerberos' `EncryptedData`
--     [RFC4120](https://tools.ietf.org/html/rfc4120#section-5.2.9) that
--     is specified to synchronise the client and server on this number.
--     The client makes a proposal, indicating where a range of `kvno`
--     values is free to be used.  The highest of the values suggested by the
--     `KX-REQ` and its matching `KX-REP` will be the `kvno` value used.
--
--     Since the server sends the last message, it can basically decide what
--     `kvno` value will be used.  Formally, the client's KDC can take the
--     initiative for revolving back to a lower `kvno` value.  This is useful
--     because the clients run the software most likely to get in trouble over
--     this.  Services should not care, and KDC's can adapt more easily.
--
--     One possible numbering scheme is to add 20,000 to a number that would
--     print as `MMDDS`: month `MM`, day `DD` and within-day serial number `S`.
--     This is not enforced, but advised to keep the keys readable.  Their
--     rotary scheme would cycle each year.  The month December might be
--     numbered in two ways, namely as `00` and as `12`, as a way to overcome
--     software problems with rotary schemes; this would be something the
--     client decides on.
--
--     A service KDC may insist on this scheme, for example to be able to count
--     the number of prior attempts (and their possible failure) to fight off
--     denial of service attacks.  It might allow higher values of `S` or
--     attempts for different `MMDD` values at a lower priority than others,
--     so as to fight off denial of service attacks.
--
--   * The `from` field defines the earliest time at which `TGS` requests
--     based on this key would be permitted.  Each side makes a proposal, but
--     the key MUST NOT be used across either sides' proposal, so effectively
--     the `from` for an established key is the latest of the two proposed
--     `from` time stamps.  Specifically user `Tickets` must not be released
--     before this latest of `from` time stamps.  One use of the `from` field
--     is to prepare early in requesting a key for continued use, which might
--     be triggered when a client uses a KXOVER key approaching its time of
--     expiration.  When absent, a value for the `from` logic is taken from
--     the `request-time` field.
--
--     The `from` field in a message MUST NOT fall before the `request-time`
--     field.
--
--   * The `till` field defines the latest time at which `TGS` requests based
--     on this key would be permitted.  Each side makes a proposal, but the key
--     MUST NOT be used across either sides' proposal, so effectively the
--     `till` for an established key is the earliest of the two proposed `till`
--     time stamps.  The timing must encapsulate the lifetime for user
--     `Tickets`, so it should not be set to expire sooner than a week in the
--     future.  On the other hand, if negotiation fails and only the service
--     ends up with a key, it is nice to see it expire, so `till` times
--     offering more than a month are not advisable either.  We suggest 14 days
--     as a default for `till` timing.  Note that it is possible to continue to
--     verify DNS on the credentials gathered to get to the key, in order to
--     learn if it may still be used.
--
--     The `till` field in a message MUST fall after both the `request-time`
--     field and the `from` field.
-- 
--   * The `etypes` field defines encryption types that the sender can create
--     for realm crossover.  The numeric values MUST be a rising sequence.
--     The sequence MAY be empty if there are no capabilities.  The sequence
--     sent in a `KX-REP` MAY specify encryption types that are not listed in
--     the matching `KX-REQ` to indicate extra possibilities.
--
--     A shared secret is derived for any `etype` that overlaps between a pair
--     of `KX-REQ` and `KX-REP` messages.  The same `kvno` is assigned to all
--     these newly generated keys.
--
--   * The `extensions` field is filled with individual extensions, identified
--     by an object identifier and followed by arbitrary content.

KX-OFFER-EXTENSION ::= SEQUENCE {
        oid         [0] OBJECT IDENTIFIER,
        critical    [1] BOOLEAN DEFAULT FALSE,
        value       [2] OCTET STRING
}

-- The interpretation is very much in line with RFC 5280 for Certificates:
--
--   * `oid` holds a unique object identifier to identify the extension.
--
--   * `critical` indicates whether the extension must be recognised by the
--     recipient.  If `critical` is `TRUE` but the recipient does not know
--     about the `oid` then the exchange MUST NOT be completed.
--
--   * `value` holds any number of bytes as defined by the `oid` field.

--TODO:ABOVE:CANNOT-REDO-TGS-IN-KX:JUST-KEX-WITHOUT-FRILLS
--TODO:ABOVE:USER-TO-USER?

--TODO:MAX-USE-COUNT:BENEFITS:HASH-TREES
--TODO:DEFINE:KX-OFFER-EXTENSION
--TODO:CONSIDER:STANDARDDEF FOR ENTROPY






-- ## Establishing Crossover Keys
--
-- The purpose of KXOVER is to establish a shared key that can crossover
-- between realms.  This is done with RFC 5705, using a label and a context
-- value.
--
-- The label is the ASCII string "EXPERIMENTAL-INTERNETWIDE-KXOVER" prior to
-- registration, and "INTERNETWIDE-KXOVER" once it is registered.
--
-- The context value is the byte sequence obtained by encoding the below
-- definition for `KXOVER-KEY-INFO` in DER.
--
-- The output of the RFC 5705 exporter should be taken as long as the key.
-- RFC 3961 requires that this is always a whole number of bytes.  These
-- bytes are passed into the targeted encryption type's random-to-key
-- operation, which is defined for any Kerberos5 encryption type, also
-- according to RFC 3961.

KXOVER-KEY-INFO ::= SEQUENCE {

        -- Identity information:
        kx-name         [0] KRB5PrincipalName,          -- from KX-OFFER
        req-name        [1] KRB5PrincipalName,          -- from KX-OFFER.my-name in KX-REQ
        rep-name        [2] KRB5PrincipalName,          -- from KX-OFFER.my-name in KX-REP

        -- Timing information:
        from            [3] KerberosTime,               -- from KX-OFFER, the latest
        till            [4] KerberosTime,               -- from KX-OFFER, the earliest

        -- Key descriptive information:
        kvno            [5] KeyVersionNumber,           -- from KX-OFFER
        etype           [6] EncryptionType,             -- from KX-OFFER, one at a time

        -- Additional salt:
        req-salt        [7] OCTET STRING,               -- from KX-OFFER.salt in KX-REQ
        rep-salt        [8] OCTET STRING,               -- from KX-OFFER.salt in KX-REP

        -- Extensions:
        extension-info  [9] SEQUENCE OF KX-OFFER-EXTENSION
}

-- The `kx-name` value is taken from the `KX-OFFER`; this value is the
-- same in both directions.  The `req-name` and `rep-name` come from the
-- `my-name` field in the `KX-OFFER`, respectively from the `KX-REQ` and
-- `KX-REP` messages.
--
-- The `from` value represents the latest of the two values in `KX-REQ`
-- and `KX-REP`.  The `till` value represents the earliest of the two
-- values in `KX-REQ` and `KX-REP`.
--
-- The `kvno` value is taken from the `KX-OFFER` in the `KX-REP`.  This
-- value is often based on the suggestion of `kvno` in `KX-REQ`, but it
-- is not incorporated in this calculation.
--
-- The `etype` is a value that has occurred in the `etypes` field in both
-- the `KX-REQ` and `KX-REP`.  The overlap should be non-empty, and may
-- hold multiple encryption types; the same `kvno` can be used with multiple
-- `etype` values because `kvno` is not used witout `etype` in Kerberos.  The
-- various `etype` and `kvno` pairs each derive their own `KXOVER-KEY-INFO`
-- and corresponding secret key.
--
-- The `req-salt` and `rep-salt` are taken from the `salt` field in the
-- `KX-OFFER` as respectively found in `KX-REQ` and `KX-REP`.
--
-- The `extension-info` may be an empty list or a longer one, though care
-- should be taken not to be too demanding on the size of the RFC 5705
-- exporter mechanism.  The elements of this list are dictated by the
-- `extensions` fields in `KX-REP` and `KX-REQ` respectively, and within
-- these fields, the order of the `extensions` determines the order of
-- the `extension-info` field.  An extension may for instance specify two
-- OID-identified elements in `extension-info` for `KX-REP` and none for
-- the same extension in `KX-REQ`.  Or it may only add an element to the
-- `extension-info` when an offer in `KX-REQ` is answered in a `KX-REQ`.
-- It is generally useful to be mild on expectations on software, and do
-- little more than copy values in an `extension`.
--
-- One possible use of `extensions` may be a reference to one or more
-- shared keys that were previously setup.  To allow an M-out-of-N scheme
-- for these, it would be possible to compute the shortest distance from
-- the origin to an affine space with N vectors spanning M degrees of
-- freedom, and store the result in the `extension-info`.  This could be
-- used to integrate both out-of-band keys and previously shared (and
-- still valid) keys.  Such a mechanism could help to fend off attacks by
-- Quantum Computers while still relying on algorithms sensitive to them.


-- ## Key Sharing between KDCs
--
-- The `KX` exchange establishes shared keys for a certain time.  Based on these
-- keys, the client KDC can construct Ticket Granting Tickets that last for one
-- user session.  At some point near the end of the lifetime of the realm
-- crossover key however, it may not be possible to supply keys to users that
-- last as long as the client's ticket.  A shorter-lived ticket can then be
-- returned to the user, but it is helpful to anticipate later renewal by
-- running KXOVER once more and setup a newer key.  This is a completely new
-- key; given the automation of the process, there is no reason to complicate
-- the protocol and software and perhaps risk security as a result.


-- ## Key Sharing between Others
--
-- There is no reason why others than two KDCs could not use KXOVER to share
-- keys.  This is why the `req-name` and `rep-name` are made explicit.  Though
-- Kerberos defines no strict procedures on what to do in such situations,
-- the basic idea of Kerberos is invariably that two parties can communicate
-- as soon as they share a key; the only problem is that a Ticket holds a
-- version of the key to the remote that was encrypted by the KDC with a
-- long-lasting secret for the two parties, so that phase must be skipped,
-- but any further use of Kerberos would work.
--
-- Looking at RFC 4120, messages that are usable without Ticket but with a
-- shared key include `KRB-SAFE`, `KRB-PRIV` and even `KRB-CRED`.  Further
-- integration into protocols with MIME Content-Types or TLS' ALPN and of
-- course GSS-API would be possible, should applications need this.
--
-- In service of this kind of pattern, this specification emphasises the use
-- of the KDC host name in the certificates used by KXOVER end points, even
-- when the end points represent a principal.  There is no requirement for
-- the IP address of an end point to be one owned by the KDC, but it is a
-- security requirement that the name of a KDC host is used and that both
-- that host name and the certificate can be validated under the DNS mapping
-- for the realm.  Note that DANE can validate end certificates for a KDC
-- and/or a signing certificate under which principals are signed.  These
-- concerns were also present in PKINIT, but KXOVER makes them publicly
-- verifiable through DANE and DNSSEC.


-- ## Certificate Profile for KXOVER
--
-- KXOVER runs over TLS, and requires that both client and server present
-- a certificate as part of the handshake.  There will be no renegotiation
-- or additional request to ask for a client certificate after the first
-- handshake, so it will be requested and provided right away.
--
-- The TLS handshake validates ownership of the certificate by seeking
-- proof that each side holds the private key matching the certificate.
-- The authority of the certificate is sought through DANE, and is based
-- on the contained server host name for the KDC (also when the owner of
-- the certificate is a client of that KDC) and, if locally administrative
-- policy requires it, the certificate may have to fall under a certain
-- certificate hierarchy.
--
-- The certificate itself expresses `KRB5PrincipalName` structures in the
-- `SubjectAltName` extension, as is the case with PKINIT.  These mention
-- both the `PrincipalName` and `Realm`; the certificate expresses that
-- these are identities belonging to the certificate owner, which would
-- be confirmed by the authenticity of the certificate.  Authenticity is
-- defined by a KDC server host, but the authenticity of this host name
-- must be related to a `Realm` being considered.  The `Realm` and related
-- `PrincipalName` are provided by the other side in the `my-name` value
-- in the `KX-OFFER` sent by the remote peer after TLS is setup.
--
-- So, what does a certificate need to support?
--
--   * One or more `KRB5PrincipalName` values for `SubjectAltName`, as are
--     used under PKINIT.
--
--   * One hostname, preferrably as one `DNSName` value under the same or
--     another `SubjectAltName` extension, or as `cn` field in the
--     `Subject` of the certificate.
--
--   * The certificate will be validated under DANE and DNSSEC.  This may
--     take any of its forms, like end certificate, intermediate or root,
--     as well as self-signed or as part of a certificate hierarchy.
--
--   * The realm(s) for which the certificate is to be used must hold an
--     SRV record pointing to the KDC host name, protected by DNSSEC.
--     The SRV record prefixes _kerberos-tls._tcp to the DNS-mapped name
--     for the realm.
--
--   * If so desired by the administrative policy on a remote relying
--     KDC, the certificate must be part of a certificate hierarcy that
--     it trusts.
--
--   * Once available, support for signatures and key exchange algorithms
--     that are safe from Quantum Computers.  It is not yet clear how
--     future standards will split this out between certificates and the
--     TLS protocol.


-- To facilitate the `KX` exchange, a KDC needs a certificate under the
-- following constraints:
--
--   * The certificate holds a *realm set* name to claim its realm names; this
--     MUST contain the `CLIENT.NAME` part of the `kx-name` when the certificate
--     is used to sign for a `KX-REQ`; and it MUST contain the `SERVICE.NAME`
--     part of the `kxrealm` when the certificate is used to sign for a
--     `KX-REP`.  Note that it is possible for additional realms to be
--     contained, which is quite acceptable, and only presence of the realm
--     from the `kx-name` is assured.
--
--   * The certificate holds an Extended Key Usage OIDs as defined in
--     [RFC5280](http://tools.ietf.org/html/rfc5280#section-4.2.1.12)
--     to indicate support for `KX`; for the certificate signing the `KX-REQ`,
--     the OIDs MUST include `id-kxover-kdc-service`; for the certificate
--     signing the `KX-REP`, the OIDs MUST include `id-kxover-kdc-client`.
--     It is possible and even likely for general-purpose KDCs to use
--     certificates that hold both OIDs, so they can be used in both directions.
--
-- Certificates that supply this information properly are considered acceptable
-- signers, but validating their signatures involves more validation steps:
--
--   * The certificate chain in `signature-owner` is acknowledged by the
--     DNS-based validation procedure described below; this is the vital step
--     for the support of impromptu realm crossover.
--
--   * The validation of the certificate chain in `signature-owner` MUST
--     succeed.
--
--   * Local policy MAY require additional interrogation of CRLs, OCSP and
--     so on.
--
--   * Local policy MAY restrict the last certificate in the `signature-owner`
--     chain to be one of a list of accepted CAs.
--

-- The *realm set* extension is a value in the `subjectAltName` extension
-- [RFC5280](http://tools.ietf.org/html/rfc5280#section-4.2.1.6) which
-- holds a set of realm names that the KDC claims to administer; the extension
-- is of the form `OtherName`, with `type-id` set to `id-kxover-krb5realm` and
-- `value` set to the `KRB5RealmSet` structure defined below:

id-kxover-krb5realmset OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        san(2) realmset(1) }

KRB5RealmSet ::= SET OF Realm

-- The OIDs representing the Extended Key Usage patterns of KXOVER are:

id-kxover-kdc-service OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        role(1) kdc-service(0) }

id-kxover-kdc-client OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        role(1) kdc-client(1) }

id-kxover-princ-service OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        role(1) princ-service(2) }

id-kxover-princ-client OBJECT IDENTIFIER ::= {
        1 3 6 1 4 1 arpa2(44469) experimental(666) kerberos(88) kxover(1)
        role(1) princ-client(3) }


-- ## DNS-based Validation
--
-- DNS-based validation is the one requirement that MUST be met for all
-- certificates used in the KXOVER framework.  This permits the current habit
-- of KDC-local CAs that can be connected through validation with DNSSEC and
-- DANE.  These technologies are based on public-key cryptography under control
-- of Kerberos and DNS infrastructure operators, respectively.
--
-- The two technologies enhance each other; DANE information is located in DNS,
-- validated through DNSSEC to be present and correct, and only when this is
-- the case will they consider a signer's certificate acceptable, and as a
-- result, the supplied `KX-OFFER` contents.
--
-- This results in a global framework of authenticity.  The built-in ECDH key
-- agreement is also authenticated, allowing the setup of rolling shared keys
-- between the end points, which is used to construct a realm crossover key
-- that in turn allows the creation of Ticket Granting Tickets for KDC clients.
--
-- The method by which the client's KDC establishes the realm to which it needs
-- to crossover is considered to fall outside the scope of this specification.
-- Do note that "independent" work has been done on establishing _kerberos TXT
-- records in DNS, also protected through DNSSEC.
--
-- The validation between KDCs is mutually done.  When a KDC (referred to below
-- as the *validating KDC*) wants to validate another, (referred to as the
-- *evaluated KDC*) for which it has a claimed- realm (the *evaluated realm*),
-- it proceeds as follows:
--
--  1. Demanding DNSSEC for security, the validating KDC extracts an `SRV`
--     record under the DNS-mapped name of the evaluated realm, to find the
--     address and port of the evaluated KDC.  This is considered the
--     authoritative information for the evaluated realm, and leading for
--     identifying key material.  This is so strong that there is no
--     requirement to verify the address and port information against incoming
--     requests.
--
--  2. Demanding DNSSEC for security, the validating KDC extracts the `TLSA`
--     records for the evaluated KDC service.
--
--  3. Upon arrival of the `KX-OFFER` structure from the other side, the
--     `TLSA` record data is used to validate the `signature-alg` and
--     `signature-value`, possibly based on the `signature-owner` chain of
--     certificates.  Note that KDC clients tend to enforce short timeouts on
--     their UDP communication with the server, so only special circumstances
--     should rely on the `signature-owner` chain; it is generally advised to
--     keep it short, or perhaps empty.  The one exception to this rule is
--     usually within a federation, where the extra delays may be acceptable
--     due to local caching of known peers.
--
--  4. Any places where the DNS supplies multiple values it will be seen as
--     alternative paths of establishing the desired certainty.  When just one
--     such path succeeds, the evaluated KDC is approved.



--TODO:ALPN


END
